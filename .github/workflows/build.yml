#
name: Build and push Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ["main"]
    workflow_dispatch:

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: chess-api
  REPO_NAME: kevintsander-org
jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      packages: read
    container:
      image: ghcr.io/kevintsander/rails-free-tds-image:main

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      # - name: Set up Ruby
      #   uses: ruby/setup-ruby@v1
      #   with:
      #     ruby-version: "3.3.4"

      - name: Install dependencies
        run: bundle install

      - name: Run tests
        run: bundle exec rspec

  update-version:
    needs: test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Increment version
        run: |
          current_version=$(cat .version)
          IFS='.' read -r -a version_parts <<< "$current_version"
          version_parts[2]=$((version_parts[2] + 1))
          build_number=$(date +%Y%m%d%H%M%S)
          new_version="${version_parts[0]}.${version_parts[1]}.${version_parts[2]}.${build_number}"
          echo $new_version > .version
          echo "Updated version to $new_version"

      - name: Commit and push version update
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .version
          git commit -m "Bump version to $(cat .version)"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    needs: update-version
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        id: push
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see "[AUTOTITLE](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds)."
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}

      - name: Create build artifact
        run: echo "imageDigest=${{ steps.push.outputs.digest }}" > build_artifact.txt

      - name: Upload build artifact
        uses: actions/upload-artifact@v3
        with:
          name: build-artifact
          path: build_artifact.txt
